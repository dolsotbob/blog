<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>나의 블록체인 블로그</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <header>
        <h1>나의 블록체인 블로그</h1>
        <p style="color: #ff4d94; font-size: 24px; text-align: center";
        >블록체인 부트캠프 일지</p>
    </header>

    <div class="container">
            <div class="container"></div>
            <div class="item">홈</div>
            <div class="item">소개</div>
            <div class="item">블로그</div>
            <div class="item">문의</div>
    </div>

    <main>
        <section id="home">
        <h2>안녕하세요.</h2>
        <p>
            이 곳은 블록체인 꿈나무 윤정아의 블로그입니다. 반갑습니다.
        </p>
        </section>
    
        <section id="about">
        <h2>소개</h2>
        <p>저는 블록체인 엔지니어 부트캠프에 참여하고 있고, 부트캠프에서의 일지를 시작으로 블록체인에 대한 다양한 이야기를 나누려 합니다.</p>
        </section>

        <section id="blog">
            <h2>최신 글</h2>
            <article>
                <h3>비트코인의 탄생 배경</h3>
                <p>
                2025년 2월 3일 <br>
                <br>
                블록체인이란? <br>
                데이터가 해시값으로 블록에 기록되어 있고 블록들이 시간 순서대로 연결되어 있는 것. 
                <br>
                <br>
                블록체인이 만들어진 배경은? <br>
                89년, 한 연구자의 연구 결과가 조작된 것이라는 스캔들을 본 과학자 스콧 스토네타가 디지털 기록의 중요성을 절감했고, 암호학자인 스튜어트 하버와 함께 디지털 기록의 불변성에 대한 공동 연구를 해 만들었다. 그들이 만든 블록체인의 기본 메커니즘은 데이터 전체가 아닌 해시값만 전송해서 타임스탬프를 부여받고 이를 디지털 서명으로 보증받는다는 것이었다. 
                <br>
                <br>
                비트코인은 화폐일까? <br>
                다음 화폐 3대 요소를 갖추고 있는지를 기준으로 살펴보자. 
                <ol>
                    <li>교환의 매개체: 아직 대부분의 사람들은 실생활에서 비트코인을 사용해 교환/거래 하지 않는다.</li>
                    <li>가치 척도의 기능: 스테이블 코인의 등장으로 가치 척도가 어느정도 가능해졌지만 여전히 높은 가격 변동성으로 인해 가치 척도의 기능을 온전히 해내기 어렵다.</li>
                    <li>가치 저장의 기능: 비트코인이 이 기능은 현재 가지고 있다. 이미 일부 국가에서는 법정화폐를 대신해 사용되기 시작했다.</li>
                    </ol>
                    <br>
                여기서 블록체인 엔지니어로서 고민할 부분을 찾을 수 있다.  
                <ul>
                <li>마트에서 비트코인으로 계산하기 어려운데 사용성을 향상할 방법은?</li>
                <li>가치 척도의 기능으로서의 한계를 극복할 방법은?</li> 
                </ul>
                <br>
                <br>
                새 기술은 문제 해결을 위해 태어난다. 비트코인은 어떤 문제 해결을 위해 태어났을까? <br>
                2000년대 IT 버블 붕괴, 아프간/이라크 전쟁 등으로 미국 경기가 약화되지 미국은 초 저금리 정책을 펼쳐 대응한다. 부동산 가격이 상승하기 시작했고 금융사는 신용 등급이 낮은 사람에게도 주택 담보 대출을 해주기 시작했다. <br>
                2004년, 미국 경제가 회복세에 들어가면서 초 저금리 정책을 종료했고 부동산 버블이 터지면서 엮여있는 금융사들이 파산하기 시작했고 이는 새계 금융 위기로 이어졌다. 
                금융 위기에 대한 정부의 대응책은 양적 완화였다. 화폐를 계속 찍어 신용창출을 하며 경제 위기를 해결했지만 다음과 같은 부작용이 있었다. 
                <br>
                양적완화는 금융위기 극복과 경제 부양에 큰 역할을 했지만 자산 버블, 인플레이션, 부의 양극화, 금융 불안정, 신흥국의 외환위기 위험 증가 등의 부작용이 있었다.<br>
                <br> 
                개인정보 관련 정부와 대기업의 행보에 반해 개인의 프라이버시를 중요시하는 사람들이 ‘시이퍼 펑크’라는 단체를 만들어 탈 중앙화된 문화를 옹호하는 사회운동 시작했다. 
                그리고 사토시 나카모토의 비트코인 백서는 사이버 펑크에 보낸 이메일를 통해 처음 세상에 선보이게 된다. 
                사토시는 추후 사이버 펑크 멤버들과 소통하며 비트코인 개발한다. <br>
                <br>
                비트코인 제네시스 블록에 기록된 메세지
                <br>
                The Times 03/Jan/2009 Chancellor on brink of second bailout for banks <br>
                금융위기에서 영국 정부의 은행 구제금융에 대한 비판적 메세지. <br>
                이는 비트코인 탄생의 목적을 명확히 한다: 
                <ol>
                <li>중앙화 금융 시스템의 블안정성과 문제점 비판</li>
                <li>탈중앙화 금융의 대안 제시</li>
                </ol>
                블록체인은 디지털 세상에서 데이터의 신뢰를 만들어내는 신뢰의 기술이다. 
                <br>
                나만의 문제 인식과 그 해결을 위한 블록체인 활용법에 대해 스케치 하며 공부해보자. 

                </p>
            </article>

            <article>
                <h3>해시와 디지털 서명</h3>
                <p>2025년 2월 4일<br>
                <br>

                    SHA-256 알고리즘 작동 과정을 알아보자. 
                    <ol>
                    <li>입력 데이터 준비 : 입력 데이터는 고정된 크기(512비트 블록)로 처리되고 필요한 경우 패딩을 통해 데이터를 맞춘다.</li>
                    <li>초기 해시 값 설정 : SHA-256은 8개의 32비트 초기 해시 값을 정의한다. 이 값들은 암호학적 연구를 통해 설정된 상수이고 이 값들이 초기값이 되어 64번의 Round를 거친 후 나오게 된다.</li>
                    <li>메시지 처리 : 입력 데이터는 512비트 블록 단위로 처리됨. 메시지 스캐줄 생성 > 해시 압축 함수(라운드 연산)</li>
                    <li>최종 출력 및 최종 해시 값 생성</li>
                    </ol>
                <br>
                <br>
                블록 해시에는 어떤 것들이 포함되어 있을까? 
                    <ul>

                    </ul>    
                    <li>이전 블록의 해시 값</li>
                    <li>머클 루트: 블록 내 모든 트랜잭션의 요약 값</li>
                    <li>난이도 목표: 작업증명에 필요한 해시의 난이도</li>
                    <li>논스: 작업 증명을 완료하기 위해 반복적으로 변경되는 값</li>
                    </ul>
                    
                    <br>
                    블록 해시 역할은?<br> 
                    블록 간 연결성 유지 & 변경된 데이터 탐지
                    <br> 
                    <br>
                서명의 역할은?<br> 
                문서의 진위성과 무결성 보증한다.  
                서명을 함으로써 나는 이 문서를 확인했고, 문서의 내용에 동의하며, 문서가 변조되지 않았음을 보증한다는 의미를 전달한다. <br>
                <br>
                
                디지털 서명은 어떻게 이루어지나?<br>
                <ul>
                <li>발신자가 개인키를 사용해 서명</li>
                <li>수신자는 공개키로 서명을 검증해 다음을 확인할 수 있다.</li>
                </ul>
                       
                무결성 보증: 데이터가 전송 중 변조되지 않았는지
                진위성 확인: 데이터를 서명한 사람이 신뢰할 수 있는 발신자인지
                
            </ul>
                    
            <br>
            <br>
            디지털 서명은 어떻게 진행될까요? 
            <ol>
            <li></li>데이터 해싱
            <li></li>서명: 송신자는 개인티로 해시 값에 서명함. 이 서명은 암호화된 해시값으로 서명자는 해당 데이터의 무결성과 진위성 보증 (디지털 서명은 개인키로 암호화 되었기 때문에 공개키로 복호화 할 수 있고, 복호화하면 원본 데이터의 해시 값이 나옴)
            <li></li>검증 : 수신자는 송신자의 공개키로 디지털 서명을 복호화 함. 검증 과정에서 다음 두 데이터 비교.
            <li></li>송신자의 공개키로 디지털 서명을 복호화 해서 원본 데이터의 해시값 구함
            <li></li>원본 데이터를 해싱해 데이터의 해시값을 구함. 위 해시값과 같다면 데이터가 정상적으로 송신자에 의해 서명된 것임.
            </ol>
            <br>
            디지털 서명 시스템의 필요조건은? 
            <ul>    
            <li>알고리즘 : 신뢰할 수 있고 널리 사용되어 그 안전성이 입증된 해시 함수(SHA-256, SHA-3 등)와 암호화 알고리즘(RSA, ECDSA)을 사용해야 함</li> 
            <li>구현: 알고리즘 자체는 안전하더라도 소프트웨어나 하드웨어 구현상의 취약점이 보안 사고로 이어질 수 있음</li> 
            <li> 개인 키 : 개인키 유출이나 손상 > 진위성과 부인 방지 속성 무효화됨</li>       
            </ul>

            <br>
            타임스탬프에서 디지털 서명의 사용 목적:
            <ul>        
            <li>데이터 무결성 증명(특정 시점 이후 변하지 않았음, 디지털 서명으로 변조 여부 검증)</li>
            <li>시간 인증(TSA가 인증)</li>
            <li>신뢰 제공(인증 기관의 신뢰를 바탕으로 데이터 진위 보증)</li>
            </ul>
            <br>

            디지털 서명의 사용과정
            <ol>
                <li>데이터 해싱</li>
                <li>타임스탬프 생성 (TSA에서 서명해 유저에게 반환)</li>
                <li>검증: 데이터 해싱 > 반환된 타임스탬프의 디지털 서명과 비교해 TSA의 공개키를 사용해 서명이 유효한지 검증하고 데이터 해시 값이 타임스탬프에 기록된 해시값과 동일한지 확인 > 데이터가 특정 시점 이후 변경되지 않았음을 증명</li>
            </ol>        
            <br><br>    
            디지털 서명에서 사용된 알고리즘 (1) RSA 또는 DSA - TSA는 개인키로 서명하고 이를 공개 키로 검증 가능하게 함 (2) 해시 알고리즘 - 데이터 해시 값 생성 위해 SHA-1 또는 MD5와 같은 해시 함수가 사용됨
            <br><br>
            비트코인에서 디지털 서명의 역할: (1) 트랜잭션 무결성 보장 (2) 소유권 증명 (3) 탈중앙화된 검증
            <br><br>        
            비트코인에서 디지털 서명의 생성 및 검증 과정: 
            <ol>
            <li>서명 생성: 트랜잭션 데이터 준비 > 해싱 > 송신자의 개인키 사용한 해시 값 서명 > 서명과 트랜잭션 데이터 전송</li>
            <li>서명 검증: 검증 노드가 트랜잭션 데이터 해싱 > 공개 키를 사용한 검증 (서명이 유효한지, 송신자 개인키로 생성된 서명인지, 트랜젝션 데이터가 변조되지 않았는지 확인) > 검증 결과 (서명이 유효하면 네트워크에 추가) 만약 두 해시값이 다르다면, 송신자의 개인키로 생성된 서명이 아니거나 데이터가 변조되었을 가능성.</li>
            </ol>
            <br>
            <br>
            디지털 서명의 예시:<br>
            앨리스가 밥에게 0.1 BTC 보내려는 트랜잭션 생성 > 트랜잭션 해시 값을 자신의 개인 키로 서명 > 서명된 트랜젝션을 네트워크에 전송 >></br>
            네트워크의 노드가 이 트랜잭션 데이터를 해싱해서 동일한 해시 값 생성 > 공개 키를 사용해 서명 검증 > 서명이 유효하면 트랜젝션을 블록체인에 추가</br>
            디지털 서명의 장점: (1) 보안성(위조 불가능), (2) 무결성 보장(만약 데이터 변조되면 서명이 유효하지 않음), (3) 부인 방지, (4) 신뢰 기반 탈중앙화</br>
            <br><br>  
            비트코인에서 디지털 서명 활용의 특징
            <ul>
            <li>ECDSA 사용</li>
            <li>공개 키 -> 주쇼 변환 (SHA-256 + RIPMED-160)</li>
            <li>비교적 작은 서명 크기(64비트)</li>
            </ul>
            <br>

                </p>
            </article>

            <article>
                <h3>블록체인의 기본 구조</h3>
                <p>
                    2025년 2월 5일<br><br>
                    블록은 무엇으로 이루어져 있나요? 헤더와 바디 <br>
                    
                    블록 헤더는 왜 필요한가요?<br>
                    블록에 대한 메타데이터 포함하고 있고, 블록의 고유 식별자 역할을 하기 때문.<br>
                    구성: 이전 블록 해시(연결성), 머클 루트(루트 해시 값), 타임스탬프, 난이도 타켓, 논스, 버전<br>
                    <br>
                    블록 바디에는 무엇이 있나요?<br> 
                    트랜잭션 (코인베이스 트랜잭션와 일반 트랜잭션)<br> 
                    <br> 
                    트랜잭션 흐름에 대해 간략하게 설명하세요.
                    <ul>
                    <li>입력: 송신자가 이전 트랜젝션 출력((UTXO)를 참조하고, 지출할 UTXO 정보 등을 포함한 인풋에 개인 키로 디지털 서명을 한다</li>
                    <li>출력: 출력 금액 등의 정보를 포함한 아웃풋에 수신자의 주소를 지정하는 잠금 스크립트를 만든다</li>
                    <li>수신: 수신자가 공개키와 서명을 제공해 잠금 스크립트를 해제한다</li>
                    <li>검증: 노드가 입력과 출력을 검증한다</li>
                    </ul>

                    비트코인 UTXO 모델에서 내 계좌에 10,000원이 있는데 밥에게 3,000원을 송금했다. 이 과정을 설명하세요.<br>
                    내가 갖고 있던 10,000의(UTXO) 상태가 “사용됨(입력, Input)”으로 변하고, 밥에게 3,000(UTXO)이 “미사용됨(출력, Output)”으로 생성된다. 내 계좌에는 수수료를 뺀 나머지 69999.999원(UTXO)이 “미사용됨(출력, Output)”으로 생성된다. 비트코인은 필요한 금액만큼 UTXO을 소모하고 잔액은 새로운 UTXO로 생성됨.
                    <br><br>

                    UTXO란?<br>
                    <li>Unspent Tranxaction Output의 약자로 이전 트랜잭션에서 생성되었지만 아직 소비되지 않은 출력을 말한다.</li>
                    <li>내 지갑이 모든 UTXO를 더하면 잔고가 된다.</li>
                    <li>이미 소비된 UTXO는 다시 사용할 수 없어 "이중지불" 방지의 역할을 한다.</li>
                    <br><br>
                    이더리움과 비트코인의 차이점은?<br>
                    비트코인은 UTXO기반 모델이고 이더리움은 계정 기반 모델임.<br>
                    비트코인과는 달리 이더리움에서는 반복문을 쓸 수 있어 스마트 컨트랙트를 만들기 더 용이하다. 해커의 공격을 막기 위해 가스비를 도입해 공격할 때마다 가스비를 써야 하도록 설계했다.<br>
                    <br>
                    OP 코드로 각 트랜잭션이 올바르게 작동하는지 검증할 때 어떤 것을 보나요?<br>
                    소유자 확인, 출력 주소와 금액 확인, 다중 서명 및 공개 키 변조 방지<br>
                    <br>
                    <br>머클 루트는 어떤 역할을 하나요?<br>
                    마클 트리에서 하나의 트랜잭션만 변경해도 머클 루트가 변함으로써 데이터 무결성을 보장하고 위변조를 방지합니다.<br>
                </p>
            </article>
            
            <article>
                <h3>블록체인의 작동원리</h3>
                <p>2025년 2월 6일</p>
                
                <h4>사토시 나카모토는 중앙 집중형 원장의 어떠한 특징을 해결하고 싶어했나요?</h4>
                <ul>
                    <li>중앙화된 신뢰: 데이터의 신뢰가 국가와 같은 중앙 기관의 신뢰성과 권위를 기반으로 형성되는 점</li>
                    <li>단일 장애점: 중앙 서버가 해킹, 손상, 장애를 겪으면 데이터가 유실되거나 손상될 위험이 있음.</li>
                    <li>투명성 부족</li>
                </ul>

                <h4>중앙 집중형 원장의 특징 중 어떤 것이 사타시 나카모토의 최우선 과제가 아니었나요?</h4>
                <li>율성: 중앙 기관이 직접 데이터를 관리해서 처리 속도가 빠를 수 있음</li>
                
                <h4>분산원장이란 무엇인가요?</h4>
                <li>데이터를 중앙 서버가 아닌 네트워크의 여러 노드에 걸쳐 분산 저장하는 데이터베이스의 일종. 중앙기관 없이 데이터의 무결성과 보안이 유지됨.</li>
            
                <h4>분산원장의 종류로 어떤 것이 있나요?</h4>
                <ul>
                    <li>퍼블릭 (예: 비트코인, 이더리움)</li>
                    <li>프라이빗: 제한된 참여자만 접근 가능. 기업 내부에서 사용됨. (예: 하이퍼레저, 리플)</li>
                    <li>컨소시엄: 특정 그룹(기업 연합 등) 내에서 공유되며, 참여 노드가 제한됨.</li>
                </ul>

                <h4>중앙 집중형 원장과 분산원장의 대표적 차이점 몇 가지를 얘기해보세요.</h4>
                <ul>
                    <li>데이터 추가/수정 가능 여부: 중앙 집중형 원장에서는 가능, 비트코인에서는 불가능</li>
                    <li>신뢰 형성 방법: 중앙 집중형에서는 중앙 기관의 권위 사용, 비트코인에서는 합의 알고리즘과 암호화 기술 사용</li>
                    <li>확장성: 중앙 집중형에서는 높음(중앙화된 처리), 비트코인에서는 낮음(분산 처리로 인한 제한)</li>
                </ul>

                <h4>합의 알고리즘이란?</h4>
                <li>무엇이 우선시 되어야 하는가를 정의하는 것. 예를들어 블록이 포크 되었을 때 무엇을 우선시 해야 할까? 비트코인의 경우 작업을 많이 한 체인이 우선시 됨.</li>

                <h4>분산 원장 기술의 작동 방식을 설명하세요.</h4>
                <ol>
                    <li></li>
                </ol>

            </article>

            <article>
                <p>
                    <h3>이더리움</h3>
                    <p>
                        2025년 2월 7일<br>
                    </p>
                </p>
            </article>

            <article>
                <h3>기초 - 웹 개발 이해하기</h3>
                <p>
                    2025년 2월 10일<br>
                </p>
            </article>

            <article>
                <h3>Git</h3>
                <p>2025년 2월 11일</p>
                <h4>깃 워크플로우</h4>
                깃은 파일 상태 관리를 위해 다음 세 가지 영역을 사용: 
                <ol>
                    <li>Working Directory: 로컬에서 작업중인 파일들이 위치하는 공간. 파일이 수정되면 Git이 추적하지만 아직 저장소에 반영되지 않은 상태</li>
                    <li>Staging Area: 커밋하기 위해 준비된 파일들이 임시로 저장된 공간. git add 명령으로 스테이징 영역에 추가</li>
                    <li>Repository: Git 이 관리하는 데이터베이스. git commit 명령으로 스테이징 영역의 파일이 저장소에 반영되고 변경 이력이 기록됨.</li>
                </ol>
                파일을 로컬에서 원결으로 깃허브에 올릴 때 쓰는 명령어는?
                <ol>
                    <li>git add (파일이름) 혹은 git add . : 마치 노드 멤풀에 트랜잭션이 모여있는 것과 같은 상태</li>
                        <ul>파일 상태는 Untracked(Git에서 관리하지 않는 파일) 또는 Modified(수정된 파일)로 표시됨</ul>
                        <ul>스테이징 영역에 추가</ul>
                    <li>git commit -m '메세지': 동료들이 내 메세지를 보고 어떤 작업을 했는지 파악할 수 있도록 메세지 작명</li>
                        <ul>변경사항을 로컬 저장소에 기록</ul>
                    <li>git push origin main: 여기서 origin은 이 코드가 원래 있어야 할 곳 (마스터 브랜치, 여기선 원격저장소); main은 브랜치</li>
                        <ul>원격 저장소에 업로드</ul>
                </ol>

                <h4>브랜치</h4>
                핵심 개념 
                <ul>
                    <li>독립적인 작업 공간: 기존 코드에 영향을 주지 않고 새 작업 수행 가능</li>
                    <li>경량화된 포인터: Git에서 브랜치는 특정 커밋을 가리키는 포인터(참조); 새로운 커밋이 추가되면 브랜치는 자동으로 해당 커밋을 가리키도록 이동함</li>
                    <li>기본 브랜치와 병렬 브랜치: main과 master; feature와 fix</li>
                </ul>

                <p>브랜치끼리 충돌할 때 덮어쓰지 말기</p>
                다음 명령어 쓰기:<br> 
                git pull origin main --no-rebase 
                <ul>
                    <li>rebase: 우리 코드가 먼저다, 덮어 써라는 뜻</li>
                    <li>덮어쓰지 않도록 no rebase</li>
                </ul>
                <p>
                    브랜치 만들고 그 브랜치로 이동할 때 쓰는 명령어:<br>
                    git checkout -b 브랜치 이름 
                </p>
                충돌 방지 위해 아래 습관화 하기 (출근 하자 마자 할 것): 
                <ul>
                    <li>git fetch --all: 모든 원격 저장소 최신호</li>
                    <li>git pull origin main: 원격 저장소 origin의 main 브랜ㅇ치 코드 가져옴</li>
                </ul>
            </article>

            <article>
                <h3>HTML</h3>
                <p>2025년 2월 12일</p>
                
                <h4>HTML이란?</h4>
                <p>웹 페이지의 뼈대를 구성하는 마크업 언어.</p>
                
                <h4>HTML의 특징은?</h4>
                    <ul>
                        <li>하이퍼텍스트: 문서간 연결</li>
                        <li>마크업 언어: 텍스트에 태그를 추가해 구조와 의미 정의</li>
                        <li>브라우저가 읽고 해석해 웹페이지로 렌더링</li>
                    </ul>
                    
                <h4>HTML의 구성요소는?</h4> 
                    <ol>
                        <li>!DOCTYPE html: 브라우저가 HTML5 규격에 맞게 콘텐츠 해석하도록 지정</li>
                        <li>html: HTML 문서의 루트요소로 모든 HTML 태그를 감쌈</li>
                        <li>head: 문서의 메타 정보 담음</li>
                        <li>body</li>
                    </ol>

                <h4>속성(attribute)</h4>
                <p>태그에 추가 정보를 제공해 해당 요소의 동작이나 스타일을 설정하는 데 사용됨. <br>
                    속성명="값"의 형식으로 표현됨 </p>
                    자주 사용하는 속성명
                    <ul>
                        <li>id, class</li>
                        <li>href</li>
                        <li>src</li>
                        <li>alt</li>
                        <li>style</li>
                        <li>title</li>
                        <li>input</li>
                    </ul>
                <a href="https://developer.mozilla.org/ko/docs/Web/HTML/Element">HTML 요소 참고서</a>
            </article>

            <article>
                <h4>SEO, 검색 엔진 최적화</h4>
                <p>검색 엔진에서 웹사이트가 더 높은 순위에 노출되도록 최적화하는 작업</p>
                <p>SEO 태그 사용의 중요성</p>
                <ul>
                    <li>검색 엔진에 정보 제공</li>
                    <li>검색 순위 향상</li>
                    <li>사용자 경험 개선</li>
                </ul>
            </article>
        
            <article>
                <h3>HTTL과 CSS는 어떻게 연결하나요?</h3>
                <p>Link 태그 또는 내부 스타일로 연결할 수 있습니다.</p>
                <ol>
                    <li>외부 스타일시트 연결: link rel="stylesheet” href=“css/styles.css”</li>
                    <li>내부 스타일시트: HTML 파일 안에서 style 태그를 사용</li>
                    <li><인라인 스타일: HTML 요소에 직접 스타일 정의/li>
                </ol>
                
                외부 스타일시트 연결할 때 주의 사항은? 
                <ul>
                    <li>경로 설정</li>
                    <li>파일 확장자는 .css</li>
                    <li>스타일시트의 로딩 순서는 순서대로 로드됨<li>
                </ul>
                
                <h4>CSS에서 ID와 Class는 각각 어떻게 쓰일까?</h4>
                <p>ID는 문서 내에서 유일해야 함. 한 요소에만 적용 가능</p>
              
                <h4>링크 스타일링 할 때 어떤 태그를 쓰나요?</h4>
                <p>a</p>
                
                <h4>Flexbox와 Grid에서 누구에게 속성을 주나요?</h4>
                <p>부모에게 속성을 주고, 부모가 자식들을 정렬한다.</p> 
                
               <h4>미디어 쿼리란?</h4>
                <p>디바이스의 화면 크기, 해상도, 방향에 따라 다른 스타일을 적용할 수 있도록 도와줌. 이를 사용하면 반응형 웹 디자인(Responsive Web Design)을 구현할 수 있음.</p>
            </article>

            <article>
                <h3>Javascript (1) </h3>
                <p>2025년 2월 14일</p>
                <h4>자바스크립트에서 주석 다는 방법</h4>
                <p>// 다음에 작성, 혹은 /*, */ 사이에 작성</p>

                <h4>자바스크립트의 타입이란?</h4>
                <p>컴퓨터가 데이터를 어떻게 이해하고 처리할지를 나타내는 것. 같은 타입끼리 써야 함.</p>

                <h4>타입을 확인하는 방법은?</h4>
                <p>typeof라는 키워드 사용. 
                    <br>console.log(typeof 42); // "number"
                    <br>console.log(typeof null); // "object"
                </p>

                <h4>Math 내장 객체의 대표적은 메서드는?</h4>
                <ul>
                    <li>Math.floor(): 괄호 안의 숫자를 내림하여 반환.</li>
                    <li>Math.ceil(): 괄호 안의 숫자를 올림하여 반환</li>
                    <li>Math.round(): 괄호 안의 숫자를 반올림 하여 반환.</li>
                </ul>
                    문자열 주요 메서드: 지갑 주소 확인.비교할 때 유용함<br>
                    논리 부정 연산자(!) 주로 언제 쓰이는지: 값이 없으면 오류를 내보내줘 할 때. 오류가 날 경우 다른 방식으로 할 수 있도록.<br> 
                    변수 : 재사용 가능<br> 
                    변수 선언 > 메모리에 공간 확보<br> 
                    할당 > 값을 메모리 공감에 저장<br>
                    =는 저정한다는 뜻<br> 
                    템플릿 리터럴: 문자의 내부에 변수를 삽입할 수 있는 기능. 정말 많이 쓰임.<br>
                    Return문: 터미널 출력이 안됨. </p>
            </article>

        </section>

        <section id="contact">
            <h2>문의</h2>
            <p>
                이메일: <a href="mailto:chatjip9@gmail.com">chatjip9@gmail.com</a>
            </p>
            
            <p style="color: #46922f">블록체인에 대해 함께 공부하거나 이야기하고 싶으신 분은 이메일 주소를 남겨주세요. 스터디 모임을 할 때 연락 드리겠습니다.
                <form>
                    <input type="email" placeholder="이메일을 입력하세요" required>
                    <button type="submit" onclick="showMessage()"
                    style="background-color: #ff4d94; border= none; color: black;"
                    >제출</button>
                </form>
            </p>    
        </section>
    </main>

    

    <footer>
        <p>&copy; 2025 나의 블록체인 일지. All rights reserved.</p>
    </footer>
</body>
</html>