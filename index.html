<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>나의 블록체인 블로그</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <header>
        <h1>나의 블록체인 블로그</h1>
        <p style="color: #ff4d94; font-size: 24px; text-align: center";
        >블록체인 부트캠프 일지</p>
    

    <div class="container">
            <div class="container"></div>
            <div class="item">홈</div>
            <div class="item">소개</div>
            <div class="item">블로그</div>
            <div class="item">문의</div>
    </div>
    </header>

    <main>
        <section id="home">
        <h2>안녕하세요.</h2>
        <p>
            이 곳은 블록체인 꿈나무 윤정아의 블로그입니다. 반갑습니다.
        </p>
        </section>
    
        <section id="about">
        <h2>소개</h2>
        <p>저는 블록체인 엔지니어 부트캠프에 참여하고 있고, 부트캠프에서의 일지를 시작으로 블록체인에 대한 다양한 이야기를 나누려 합니다.</p>
        </section>

        <section id="blog">
            <h2>최신 글</h2>
            <article>
                <h3>비트코인의 탄생 배경</h3>
                <p>
                2025년 2월 3일 <br>
                
                <h4>블록체인이란?</h4>
                데이터가 해시값으로 블록에 기록되어 있고 블록들이 시간 순서대로 연결되어 있는 것. 
                <br>
                <h4>블록체인이 만들어진 배경은?</h4>
                89년, 한 연구자의 연구 결과가 조작된 것이라는 스캔들을 본 과학자 스콧 스토네타가 디지털 기록의 중요성을 절감했고, 암호학자인 스튜어트 하버와 함께 디지털 기록의 불변성에 대한 공동 연구를 해 만들었다. 그들이 만든 블록체인의 기본 메커니즘은 데이터 전체가 아닌 해시값만 전송해서 타임스탬프를 부여받고 이를 디지털 서명으로 보증받는다는 것이었다. 
                
                <h4>비트코인은 화폐일까?</h4>
                다음 화폐 3대 요소를 갖추고 있는지를 기준으로 살펴보자. 
                <ol>
                    <li>교환의 매개체: 아직 대부분의 사람들은 실생활에서 비트코인을 사용해 교환/거래 하지 않는다.</li>
                    <li>가치 척도의 기능: 스테이블 코인의 등장으로 가치 척도가 어느정도 가능해졌지만 여전히 높은 가격 변동성으로 인해 가치 척도의 기능을 온전히 해내기 어렵다.</li>
                    <li>가치 저장의 기능: 비트코인이 이 기능은 현재 가지고 있다. 이미 일부 국가에서는 법정화폐를 대신해 사용되기 시작했다.</li>
                    </ol>
                여기서 블록체인 엔지니어로서 고민할 부분을 찾을 수 있다.  
                <ul>
                <li>마트에서 비트코인으로 계산하기 어려운데 사용성을 향상할 방법은?</li>
                <li>가치 척도의 기능으로서의 한계를 극복할 방법은?</li> 
                </ul>
                <h4>새 기술은 문제 해결을 위해 태어난다. 비트코인은 어떤 문제 해결을 위해 태어났을까?</h4>
                2000년대 IT 버블 붕괴, 아프간/이라크 전쟁 등으로 미국 경기가 약화되지 미국은 초 저금리 정책을 펼쳐 대응한다. 부동산 가격이 상승하기 시작했고 금융사는 신용 등급이 낮은 사람에게도 주택 담보 대출을 해주기 시작했다. 2004년, 미국 경제가 회복세에 들어가면서 초 저금리 정책을 종료했고 부동산 버블이 터지면서 엮여있는 금융사들이 파산하기 시작했고 이는 세계 금융 위기로 이어졌다. 
                금융 위기에 대한 정부의 대응책은 양적 완화였다. 화폐를 계속 찍어 신용창출을 하며 경제 위기를 해결했지만, 자산 버블, 인플레이션, 부의 양극화, 금융 불안정, 신흥국의 외환위기 위험 증가 등의 부작용을 남겼다.<br>
                <br> 
                반면 개인정보 관련 정부와 대기업의 행보에 반해 개인의 프라이버시를 중요시하는 사람들이 ‘시이퍼 펑크’라는 단체를 만들어 탈 중앙화된 문화를 옹호하는 사회운동을 시작했다. 
                사토시 나카모토의 비트코인 백서는 사이버 펑크에 보낸 이메일를 통해 처음 세상에 선보이게 되었고, 사토시는 사이버 펑크 멤버들과 소통하며 비트코인 개발한다. <br>
                <br>비트코인의 탄생 목적은 제네시스 블록에 기록되어 있다:<br> 
                <P style="font-style: italic;">The Times 03/Jan/2009 Chancellor on brink of second bailout for banks.</p>
                이는 금융위기에서 영국 정부의 은행 구제금융에 대한 비판적 메세지로 다음과 같은 비트코인 탄생 목적을 말하고 있다: 
                <ol>
                <li>중앙화 금융 시스템의 블안정성과 문제점 비판</li>
                <li>탈중앙화 금융의 대안 제시</li>
                </ol>
                블록체인은 디지털 세상에서 데이터의 신뢰를 만들어내는 신뢰의 기술이다. 
                <br>나만의 문제 인식과 그 해결을 위한 블록체인 활용법에 대해 스케치 하며 공부해보자. 
                

                </p>
            </article>

            <article>
                <h3>해시와 디지털 서명</h3>
                <p>2025년 2월 4일

                    <h4>SHA-256 알고리즘 작동 과정을 알아보자.</h4>
                    <ol>
                    <li>입력 데이터 준비 : 입력 데이터는 고정된 크기(512비트 블록)로 처리되고 필요한 경우 패딩을 통해 데이터를 맞춘다.</li>
                    <li>초기 해시 값 설정 : SHA-256은 8개의 32비트 초기 해시 값을 정의한다. 이 값들은 암호학적 연구를 통해 설정된 상수이고 이 값들이 초기값이 되어 64번의 Round를 거친 후 나오게 된다.</li>
                    <li>메시지 처리 : 입력 데이터는 512비트 블록 단위로 처리됨. 메시지 스캐줄 생성 > 해시 압축 함수(라운드 연산)</li>
                    <li>최종 출력 및 최종 해시 값 생성</li>
                    </ol>
                
                <h4>블록 해시에는 어떤 것들이 포함되어 있을까?</h4>
                    <ul>   
                    <li>이전 블록의 해시 값</li>
                    <li>머클 루트: 블록 내 모든 트랜잭션의 요약 값</li>
                    <li>난이도 목표: 작업증명에 필요한 해시의 난이도</li>
                    <li>논스: 작업 증명을 완료하기 위해 반복적으로 변경되는 값</li>
                    </ul>
                    
                    <h4>블록 해시 역할은?</h4> 
                    블록 간 연결성 유지 & 변경된 데이터 탐지
                    
                <h4>서명의 역할은?</h4> 
                문서의 진위성과 무결성 보증한다.  
                서명을 함으로써 나는 이 문서를 확인했고, 문서의 내용에 동의하며, 문서가 변조되지 않았음을 보증한다는 의미를 전달한다. 
                
                <h4>디지털 서명은 어떻게 이루어지나?</h4>
                <ul>
                <li>발신자가 개인키를 사용해 서명</li>
                <li>수신자는 공개키로 서명을 검증해 데이터의 진위성과 무결성을 확인한다.</li>
                    <ul style="list-style-type: circle;">
                        <li>진위성 확인: 데이터를 서명한 사람이 신뢰할 수 있는 발신자인지</li>
                        <li>무결성 보증: 데이터가 전송 중 변조되지 않았는지</li>
                    </ul>
                </ul>
                       
            <h4>디지털 서명은 어떻게 진행될까요?</h4>
            <ol>
            <li>데이터 해싱</li>
            <li>서명: 송신자는 개인티로 해시 값에 서명함. 이 서명은 암호화된 해시값으로 서명자는 해당 데이터의 무결성과 진위성 보증 (디지털 서명은 개인키로 암호화 되었기 때문에 공개키로 복호화 할 수 있고, 복호화하면 원본 데이터의 해시 값이 나옴)</li> 
            <li>검증 : 수신자는 송신자의 공개키로 디지털 서명을 복호화 함. 검증 과정에서 다음 두 데이터 비교.</li>
            <li>송신자의 공개키로 디지털 서명을 복호화 해서 원본 데이터의 해시값 구함</li>
            <li>원본 데이터를 해싱해 데이터의 해시값을 구함. 위 해시값과 같다면 데이터가 정상적으로 송신자에 의해 서명된 것임.</li>
            </ol>
            <h4>디지털 서명 시스템의 필요조건은?</h4>
            <ul>    
            <li>알고리즘 : 신뢰할 수 있고 널리 사용되어 그 안전성이 입증된 해시 함수(SHA-256, SHA-3 등)와 암호화 알고리즘(RSA, ECDSA)을 사용해야 함</li> 
            <li>구현: 알고리즘 자체는 안전하더라도 소프트웨어나 하드웨어 구현상의 취약점이 보안 사고로 이어질 수 있음</li> 
            <li> 개인 키 : 개인키 유출이나 손상 > 진위성과 부인 방지 속성 무효화됨</li>       
            </ul>

            <h4>타임스탬프에서 디지털 서명의 사용 목적:</h4>
            <ul>        
            <li>데이터 무결성 증명(특정 시점 이후 변하지 않았음, 디지털 서명으로 변조 여부 검증)</li>
            <li>시간 인증(TSA가 인증)</li>
            <li>신뢰 제공(인증 기관의 신뢰를 바탕으로 데이터 진위 보증)</li>
            </ul>

            <h4>디지털 서명의 사용과정은?</h4>
            <ol>
                <li>데이터 해싱</li>
                <li>타임스탬프 생성 (TSA에서 서명해 유저에게 반환)</li>
                <li>검증: 데이터 해싱 > 반환된 타임스탬프의 디지털 서명과 비교해 TSA의 공개키를 사용해 서명이 유효한지 검증하고 데이터 해시 값이 타임스탬프에 기록된 해시값과 동일한지 확인 > 데이터가 특정 시점 이후 변경되지 않았음을 증명</li>
            </ol>        
            
            <h4>비트코인에서 디지털 서명의 역할은?</h4> 
            (1) 트랜잭션 무결성 보장 (2) 소유권 증명 (3) 탈중앙화된 검증
                  
            <h4>비트코인에서 디지털 서명의 생성 및 검증 과정에 대해 설명하세요.</h4>
            <ol>
            <li>서명 생성: 
                <ol style="list-style-type: lower-alpha;">
                    <li>트랜잭션 데이터 준비</li>
                    <li>해싱</li>
                    <li>송신자의 개인키 사용한 해시 값 서명</li>
                    <li>서명과 트랜잭션 데이터 전송</li></ol>
            <li>서명 검증: 
                <ol style="list-style-type: lower-alpha;">
                    <li>검증 노드가 트랜잭션 데이터 해싱</li>
                    <li>공개 키를 사용한 검증: 서명이 유효한지, 송신자 개인키로 생성된 서명인지, 트랜젝션 데이터가 변조되지 않았는지 확인</li>
                    <li>검증 결과 (서명이 유효하면 네트워크에 추가)</li> 
                    <li>만약 두 해시값이 다르다면, 송신자의 개인키로 생성된 서명이 아니거나 데이터가 변조되었을 가능성.</li>
                </ol>
            </ol>

            <h4>앨리스가 밥에게 0.1 BTC를 보냅니다. 트랜잭션 생성 ~ 블록체인에 추가되는 과정을 설명하세요.</h4>
            <ol>
                <li>앨리스가 0.1 BTC 보내려는 트랜잭션 생성</li>
                <li>트랜잭션 해시 값을 자신의 개인 키로 서명</li>
                <li>서명된 트랜젝션을 네트워크에 전송</li>
                <li>네트워크의 노드가 이 트랜잭션 데이터를 해싱해서 동일한 해시 값 생성</li>
                <li>공개 키를 사용해 서명 검증</li>
                <li>서명이 유효하면 트랜젝션을 블록체인에 추가</li>
            </ol>
            
            <h4>디지털 서명의 장점은?</h4> 
            (1) 보안성(위조 불가능), (2) 무결성 보장(만약 데이터 변조되면 서명이 유효하지 않음), (3) 부인 방지, (4) 신뢰 기반 탈중앙화</br>
            
            <h4>비트코인에서 디지털 서명 활용의 특징은?</h4>
            <ul>
            <li>ECDSA 사용</li>
            <li>공개 키 -> 주쇼 변환 (SHA-256 + RIPMED-160)</li>
            <li>비교적 작은 서명 크기(64비트)</li>
            </ul>
            <br>

                </p>
            </article>

            <article>
                <h3>블록체인의 기본 구조</h3>
                <p>
                    2025년 2월 5일<br><br>
                    <h4>블록은 무엇으로 이루어져 있나요?</h4>
                    헤더와 바디 
                
                    <h4>블록 헤더는 왜 필요한가요?</h4>
                    블록에 대한 메타데이터 포함하고 있고, 블록의 고유 식별자 역할을 하기 때문.<br>
                    구성: 이전 블록 해시(연결성), 머클 루트(루트 해시 값), 타임스탬프, 난이도 타켓, 논스, 버전
                    
                    <h4>블록 바디에는 무엇이 있나요?</h4>
                    트랜잭션 (코인베이스 트랜잭션와 일반 트랜잭션)
                    
                    <h4>트랜잭션 흐름에 대해 간략하게 설명하세요.</h4>
                    <ul>
                    <li>입력: 송신자가 이전 트랜젝션 출력(UTXO)를 참조하고, 지출할 UTXO 정보 등을 포함한 인풋에 개인 키로 디지털 서명을 한다</li>
                    <li>출력: 출력 금액 등의 정보를 포함한 아웃풋에 수신자의 주소를 지정하는 잠금 스크립트를 만든다</li>
                    <li>수신: 수신자가 공개키와 서명을 제공해 잠금 스크립트를 해제한다</li>
                    <li>검증: 노드가 입력과 출력을 검증한다</li>
                    </ul>

                    <h4>비트코인 UTXO 모델에서 내 계좌에 10,000원이 있는데 밥에게 3,000원을 송금했다. 이 과정을 설명하세요.</h4>
                    <ul>
                        <li>내가 갖고 있던 10,000의(UTXO) 상태가 “사용됨(입력, Input)”으로 변하고,</li>
                        <li>밥에게 3,000(UTXO)이 “미사용됨(출력, Output)”으로 생성된다</li>
                        <li>내 계좌에는 수수료를 뺀 나머지 69999.999원(UTXO)이 “미사용됨(출력, Output)”으로 생성된다.</li>
                        <li>비트코인은 필요한 금액만큼 UTXO을 소모하고 잔액은 새로운 UTXO로 생성됨.</li>
                    </ul>  
                    
                    <h4>UTXO란?</h4>
                    <li>Unspent Tranxaction Output의 약자로 이전 트랜잭션에서 생성되었지만 아직 소비되지 않은 출력을 말한다.</li>
                    <li>내 지갑이 모든 UTXO를 더하면 잔고가 된다.</li>
                    <li>이미 소비된 UTXO는 다시 사용할 수 없어 "이중지불" 방지의 역할을 한다.</li>
                    
                    <h4>이더리움과 비트코인의 차이점은?</h4>
                    비트코인은 UTXO기반 모델이고 이더리움은 계정 기반 모델임.<br>
                    비트코인과는 달리 이더리움에서는 반복문을 쓸 수 있어 스마트 컨트랙트를 만들기 더 용이하다. 해커의 공격을 막기 위해 가스비를 도입해 공격할 때마다 가스비를 써야 하도록 설계했다.<br>
                    
                    <h4>OP 코드로 각 트랜잭션이 올바르게 작동하는지 검증할 때 어떤 것을 보나요?</h4>
                    소유자 확인, 출력 주소와 금액 확인, 다중 서명 및 공개 키 변조 방지
                    
                    <h4>머클 루트는 어떤 역할을 하나요?</h4>
                    마클 트리에서 하나의 트랜잭션만 변경해도 머클 루트가 변함으로써 데이터 무결성을 보장하고 위변조를 방지합니다.
                </p>
            </article>
            
            <article>
                <h3>블록체인의 작동원리</h3>
                <p>2025년 2월 6일</p>
                
                <h4>사토시 나카모토는 중앙 집중형 원장의 어떠한 특징을 해결하고 싶어했나요?</h4>
                <ul>
                    <li>중앙화된 신뢰: 데이터의 신뢰가 국가와 같은 중앙 기관의 신뢰성과 권위를 기반으로 형성되는 점</li>
                    <li>단일 장애점: 중앙 서버가 해킹, 손상, 장애를 겪으면 데이터가 유실되거나 손상될 위험이 있음.</li>
                    <li>투명성 부족</li>
                </ul>

                <h4>중앙 집중형 원장의 특징 중 어떤 것이 사타시 나카모토의 최우선 과제가 아니었나요?</h4>
                <li>율성: 중앙 기관이 직접 데이터를 관리해서 처리 속도가 빠를 수 있음</li>
                
                <h4>분산원장이란 무엇인가요?</h4>
                <li>데이터를 중앙 서버가 아닌 네트워크의 여러 노드에 걸쳐 분산 저장하는 데이터베이스의 일종. 중앙기관 없이 데이터의 무결성과 보안이 유지됨.</li>
            
                <h4>분산원장의 종류로 어떤 것이 있나요?</h4>
                <ul>
                    <li>퍼블릭 (예: 비트코인, 이더리움)</li>
                    <li>프라이빗: 제한된 참여자만 접근 가능. 기업 내부에서 사용됨. (예: 하이퍼레저, 리플)</li>
                    <li>컨소시엄: 특정 그룹(기업 연합 등) 내에서 공유되며, 참여 노드가 제한됨.</li>
                </ul>

                <h4>중앙 집중형 원장과 분산원장의 대표적 차이점 몇 가지를 얘기해보세요.</h4>
                <ul>
                    <li>데이터 추가/수정 가능 여부: 중앙 집중형 원장에서는 가능, 비트코인에서는 불가능</li>
                    <li>신뢰 형성 방법: 중앙 집중형에서는 중앙 기관의 권위 사용, 비트코인에서는 합의 알고리즘과 암호화 기술 사용</li>
                    <li>확장성: 중앙 집중형에서는 높음(중앙화된 처리), 비트코인에서는 낮음(분산 처리로 인한 제한)</li>
                </ul>

                <h4>합의 알고리즘이란?</h4>
                <li>무엇이 우선시 되어야 하는가를 정의하는 것. 예를들어 블록이 포크 되었을 때 무엇을 우선시 해야 할까? 비트코인의 경우 작업을 많이 한 체인이 우선시 됨.</li>

                <h4>분산 원장 기술의 작동 방식을 설명하세요.</h4>
                <ol>
                    <li>트랜잭션 생성</li>
                    <li>트랜잭션이 모든 노드에 전파됨</li>
                    <li>협의 과정: 노드들이 합의 알고리즘을 통해 해당 트랜젝션의 유효성 검증</li>
                    <li>데이터 저장: 검증된 트랜잭션 원장에 기록; 노드 동기화</li>
                </ol>

                <h4>노드란?</h4>
                블록체인 네트워크에 연결된 장치.PC.

                <h4>노드는 어떤 역할을 하나요?</h4>
                데이터 저장, 데이터 검증 (블록의 유효설 검증), 네트워크 연결 및 데이터 전파, 합의 참여

                <h4>노드 유형으로 어떤 것이 있나요?</h4>
                <ul>
                    <li>풀노드 (예: 비트코인 코어 노드)</li>
                    <li>라이트 노드, SPV 노드: 머클 루트를 포함한 블록 헤더만 저장하여 작동함; 트랜젝션 검증을 위해 다른 풀 노드 필요; 예: 모바일 지갑 앱</li>
                    <li>마이닝 노드: 작업 증명을 수행해 새 블록 생성. (예: 지난 실습에서 풀노드에서는 비트코인 데몬을 켜 놓고, 마이닝 노드는 비트코인 블록을 생성 했었음)</li>
                </ul>

                <h4>알트코인에서 볼 수 있는 노드로 어떤 것이 있나요?</h4>
                <ul>
                    <li>검증 노드: 지분 증명 네트워크에서 블록 생성 및 검증. 예: 이더리움 2.0, 폴카닷, 솔라나</li>
                    <li>아카이브 노드: 블록체인의 모든 기록과 상태 데이터 자장. 주로 스마트 컨트랙트가 실행되는 블록체인(예: 이더리움, 폴카닷, 솔라나) 에서 사용됨.</li>
                </ul>

                <h4>비잔틴 장군 문제에 대해 얘기해보세요.</h4>
                <ul>
                    <li>4개 군대가 힘을 합쳐 포위하고 있는 적군의 성을 함락해야 함.</li>
                    <li>4개 군대고 동시에 공격해야만 성을 함락할 수 있음. 만약 한 군대가 배신해서 동시에 공격 못 하면 작전 실패.</li>
                    <li>해결: 각 국대가 모든 군대에게 메세지를 전파한다. > 다수결로 공격 성공</li>
                    <li>레슬리 램포트의 해법: 네트워크의 노드가 3n+1 이상이어야 최대 n명의 배신자기 있어도 합의 가능하다</li>
                </ul>

                <h4>분산된 네트워크 환경에서 악의적인 노드(배신자)가 존재할 때 이를 어떻게 극복하고, 정직한 참여자들이 올바르게 합의에 도달할 수 있을까?</h4>
                <ul>
                    <li>비잔틴 장애 허용(BFT): 네트워크 내 일부 노드가 악의적이거나 오류를 발생시켜도 나머지 정직한 노드가 올바른 합의에 도달하여 시스템이 정상적으로 작동하도록 보장하는 메커니즘.</li>
                    <li>한마디로 악의적 노드가 있어도 돌아가는 시스템을 돌아가게 하자는 것.</li>
                </ul>

                <h4 style="text-decoration: underlinep; color: orchid;">블록이 생성되는 과정을 설명해보세요.</h4>
                <ol>
                    <li>트랜잭션 생성 > 모든 노드트랜잭션 수집: 마이닝 노드가 전파된 트랜잭션을 수집해 메모리 풀에 저장</li>
                    <li> 블록 템플릿(임시 블록) 생성: 피라미드 쌓기</li>
                    <li>작업 증명(PoW): 블록 헤더의 해시값이 네트워크에서 요구하는 난이도 목표 이하의 값이 되도록 논스 값을 변경하며 반복적으로 해시 계산</li>
                    <li>블록 검증 및 전파: 유효한 해시값을 찾으면 블록이 채굴(생성)됨. > 브로드캐스트 > 다른 노드들이 새 블록의 유효성 검증</li>
                    <li>블록체인에 추가</li>
                    <li>보상 지급: 코인베이스 트랜잭션</li>
                    <li>새 블록 이후 체인 확장에 전파(브로드캐스트)</li>
                </ol>

                <h4>작업증명이 뭔가요?</h4>
                네트워크 참여자(마이너)가 퍼즐 게임에 참여해 먼저 퍼즐을 푸는 사람이 보상을 받는 경쟁적 구조.

                <h4>PoW 작동 방식을 설명하세요.</h4>
                <ol>
                    <li>트랜잭션 모으기</li>
                    <li>퍼즐 문제 해결</li>
                    <li>블록 검증</li>
                    <li>보상 지급급</li>
                </ol>

                <h4>Hash Puzzle에 사용되는 값은? 마이너는 아래 값들을 하나의 값으로 모아서 SHA-256 해시 함수를 실행함.</h4>
                <ul>
                    <li>이전 블록의 해시</li>
                    <li>머클 루트</li>
                    <li>타임 스탬프 : 이전 블록의 타임스탬프보다 크고 네트워크 현재 시간보다 2시간 이내여야 함.</li>
                    <li>난이도: 네트워크에서 설정 (예: 비트코인 목표는 10분마다 1개 블록 생성); 블록 해시 값 앞 부분에 0이 몇 개인지가 중요</li>
                    <li>논스 : 유효한 해시를 찾기 위해 반복적으로 변경되는 값; 유일한 변수</li>
                </ul>

                <h4>체인 분기(Fork)는 왜 발생하나요?</h4>
                <li>두 명의 채굴자가 동시에 블록 생성 및 브로드캐스트</li>
                <li>네트워크 지연으로 일부 노드가 특정 블록을 먼저 수신하고 다른 블록을 뒤늦게 수신했을 경우</li>

                <h4>분기 상태에 대해 설명하세요.</h4>
                <li>두 체인의 길이가 동일하며 각각 다른 노드 그룹에서 다른 체인을 유효한 체인으로 인식하는 일시적인 상태.</li>
                <li>네트워크는 가장 긴 체인(또는 가장 많은 작업량을 포함한 체인)을 신뢰하며 새 블록이 추가됨에 따라 다음 블록을 채굴하기 위한 작업이 반복됨.</li>
                
                <h4>체인 리오르그(Chain Reorganization)이란?</h4>
                분기 체인 중 가장 긴 체인 선택하는 과정. 가장 긴 체인이 메인 체인으로 선택되면, 기존의 짧은 체인의 블록들은 무효화되고 버려진 블록, 즉 고아 블록이 됨. 이 고아 블록들은 다시 멤풀로 반환되어 다른 블록에 포함될 기회를 얻게 됨.

                <h4>PoW의 장단점에 대해 말하시오.</h4>
                <ul>
                    <li>장점1: 높은 보안성</li>
                    <li>장점2: 검증 용이성(블로 헤더의 해시 값을 계산해 블록이 타켓 값 조건을 만족하는지 확인)</li>
                    <li>단점1: 에너지 소모가 큼</li>
                    <li>단점2: 확장성 문제(비트코인은 초당 약 7건의 트랜잭션 처리 할 수 있어 대규모 사용자 지원 어려움)</li>
                    <li>단점3: 높은 진입 장벽(고성능 하드웨어와 막대한 전력 비용)</li>
                    <li>단점4: 중앙화 위험</li>
                </ul>

                <h4>만약 공격자가 PoW 네트워크의 해시 파워의 51% 이상을 장악하면 어떤 일이 벌어지나요?</h4>
                <li>블록 생성 독점</li>
                <li>이중 지불: 이전 트랜잭션 취소하고 새 체인을 생성해 코인을 다시 사용</li>
                <li>네트워크 방해 : 다른 채굴자들이 유효한 블록을 생성하지 못하도록 방해.</li>
                
                <h4>PoS에 대해 설명하세요.</h4>
                지분증명. 네트워크 참여자의 지분을 기준으로 블록을 생성하고 합의를 이루는 방식.<br>
                PoW와는 달리 에너지 효율성과 확장성이 높음.
                
                <h4>PoS 네트워크에서 블록이 생성되는 과정은?</h4>
                <ol>
                    <li>지분 기반 참여: 스테이킹</li>
                    <li>검증자 선택: 네트워크는 무작위 알고리즘으로 블록 생성자 선택. 선택 기준은 스테이킹된 코인의 양과 코인을 스테이킹한 기간.</li>
                    <li>블록 검증 및 추가: 선택된 검증자가 블록 생성하면 나머지 검증자가 이를 검증하여 블록체인에 추가</li>
                </ol>             
                
                <h4>PoS의 장단점에 대해 말하시오.</h4>
                장점: 에너지 효율, 확장성(블록 생성 속도 빠름), 보안성(경제적 페널티)<br>
                단점: 지분 집중화 문제(초기 지분 많으면 유리), 복잡성(구현 및 운영 복잡)

                <h4>PoS의 보안성에 대해 설명하세요. 다음 두 보안 장치가 있음.</h4>
                <ul>
                    <li>Slashing: 악의적 검증자는 스테이킹된 자산을 잃을 위험이 있음. (예: 이더리움 2.0)</li>
                    <li>51% 공격 방지: PoW에서는 해시 파워 과반수를 장악해야 하지만, PoS에서는 네트워크의 과반수 지분을 확보해야 함.</li>
                </ul>
                
                <h4>Nothing at Stake 문제란?</h4>
                <ul>
                    <li>PoS 블록체인에서 검증자가 여러 체인에 동시에 서명해 네트워크의 신뢰성/일관성을 저하시킬 위험.</li>
                    <li>문제 원인: PoW와 달리 경제적 비용 없이 여러 체인에서 작업할 수 있는 구조.</li>
                    <li>문제의 결과: 합의 실패(혼란), 체인 분기로 인한 보안 위협(이중지불, 정당한 거래가 무효화될 가능성), 네트워크 신뢰 손상</li>
                </ul>
            
                <h4>PoS에서 Nothing at Stake 문제 해결 방안</h4>
                <ul>
                    <li>경제적 패널티(Slashing)</li>
                    <li>체인 선택 규칙 : Longest Chain Rule - 가장 긴 체인(또는 가능 많은 작업 증명을 포함한 체인)이 유효한 체인.</li>
                    <li>경제적 인센티브 설계</li>
                    <li>검증자 서명 공개</li>
                </ul>
                
                <h4>DPoS(위임 지분 증명)이 무엇인가요?</h4>
                PoS에서 고래만 계속 블록생성할 위험 (중앙화 위험)을 해결하기 위해 만들어진 것.<br>
                대표자(Delegate)를 선출해 블록 생성과 검증을 맡기고 이 대표자가 네트워크 블록 생성과 검증을 담당하는 합의 알고리즘.<br>
                PoS 효율성 개선과 PoW 탈중앙화 유지를 목표로 설계됨.
                
                <h4>DPoS 작동방식 설명하세요.</h4>
                <ul>
                    <li>대표자 선출.: 사용자가 지분을 위임하여 투표로(내 코인으로) 대표자 선출 (예: EOS)</li>
                    <li>블록 생성과 검증: 대표자들이 번갈아 가며 블록 생성; PoS처럼 복잡한 해시 계산이 필요 없어 블록 생성 속도가 매우 빠름</li>
                    <li>보상 분배: 대표자는 블록 생성으로 받은 보상을 자신에게 투표한 사용자와 공유함</li>
                    <li>대표자 교체: 사용자는 언제든 자신의 투표를 변경해 대표자 교체 가능</li>

                </ul>
                
                <h4>DPoS의 장단점에 대해 설명하세요.</h4>
                장점: 소수의 대표자가 블록을 생성해 블록 생성과 검증 속도가 빠름; 에너지 효율; 미국 대통령 선출 방식처럼 민주적 구조; 실시간 부정직한 대표자 빠르게 교체 가능
                <br>단점: 대표자 담합 등 중앙화 가능성; 낮은 투표 참여율; 대표자 신뢰 문제
                
                <h4>DPoS 블록체인 사용하는 곳은?</h4> EOS, Tron, Steem
                
                <h4>DPoS의 보안 장치는?</h4>
                대표자 교체 가능; 경제적 인센티브 (부정행위시 신뢰 잃고 보상 못 받음; Slashing); 투명성
               
                <h4>채굴이란?</h4>
                블록체인 네트워크에서 노드로 새로운 불록을 생성하여 체인에 연결하고 보상을 받는 것
                
                <h4>반감기의 역할은?</h4>
                채굴 보상이 주기적으로 절반으로 줄어들게 함으로써 암호화폐의 공급량을 조절하고 희소성을 유지하며, 궁극적으로 암호화폐의 가치를 보호함.
                
                <h4>거래수수료는 누구에게 주나요?</h4>
                채굴자와 검증자에게 보상을 지급
                <br>PoW에서는 채굴자에게만, PoS에서는 검증자에게만
                
                <h4>거래 수수료는 어디에 쓰여요?</h4>
                네트워크상의 스팸 공격 줄이기; 거래 수수료로 트랜잭션을 확인하고 유효성을 검증하는 사용자에게 인센티브를 제공함
                
                
                <h4>비트코인의 채굴자를 이더리움에서 뭐라고 부를까요?</h4>  블록 제안자(proposer)
                
              
                <h4>채굴풀이란?</h4>
                채굴을 위해 만들어진 조합<br>
                채굴 풀의 위험성(51% 공격) 을 극복한 좋은 사례: GHash.IO - 탈중앙화를 지키기위해 스스로 51% 이하로 해시 파워를 줄인 사례
                
                /////


            </article>

            <article>
                <p>
                    <h3>이더리움</h3>
                    <p>
                        2025년 2월 7일
                    </p>
                <h4>튜링 기계계</h4>
                앨런 튜링(Alan Turing)이 제안한 가상의 계산 모델<br>
                모든 계산 가능한 문제를 모델링할 수 있는 이론적 컴퓨터.

                <h4>튜링 완전성에 대해 설명하세요.</h4>
                <ul>
                    <li>토스트기 밖에 없는 주방에서는 빵 굽기 밖에 못함 (튜링 불완전함)</li>
                    <li>모든 도구와 리소스가 있는 주방에서는 어떤 요리도 가능함 (튜링 완전함)</li>
                    <li>계산기 vs. 컴퓨터</li>
                    <li>반복문과 조건문이 가능해야 튜링 완전함.</li>
                    <li>즉, 튜링 완전성은 튜링 기계와 같은 계산 능력을 가졌음을 의미한다. 어떤한 계산 가능한 문제도, 적절한 알고리즘과 충분한 리소스(시간과 메모리)가 주어진다면 해결할 수 있다.</li>
                    <li>블록체인에서 튜링 완전성을 가진 플랫폼은 더 많은 유연성을 제공하지만 동시에 더 많은 책임과 위험 관리가 필요함.</li>
                </ul>

                <h4>이더리움은 튜링 완전한가?</h4>
                네, 이더리움의 EVM은 튜링 완전성을 지원해 복잡한 스마트 계약 생성을 가능하게 함.<br>
                튜링 완전해서 생길 수 있는 문제: (1) 무한 루프 문제(이를 막기 위해 가스 제한을 둠), (2) 보안 취약점 발생 가능

                <h4>비탈릭 부테린은 왜 이더리움을 만들었나요?</h4>
                프로그래밍 가능한 블록체인을 만들겠다는 목표로 (비트토인 op 코드 몇 개로는 그러기 어려움)

                <h4>이더리움 핵심 목표는 무엇인가요?</h4>
                <ul>
                    <li>스마트 계약</li>
                    <li>DApps</li>
                    <li>프로그래밍 가능성 : 튜링 완전한 언어(Solidity)를 통해 블록체인 상에서 복잡한 프로그램 구현 가능</li>
                </ul>

                <h4>이더리움은 왜 프로그래밍이 가능한 블록체인일까?</h4>
                <ul>
                    <li>스마트 계약: Solidity와 같은 프로그래밍 언어로 작성되며, 특정 규칙을 코딩하고 이를 블록체인에 배포하여 실행할 수 있음. > 다양한 DApps을 실행할 수 있는 플랫폼이 됨.</li>
                    <li>EVM: 이더리움 네트워크에서 스마트 계약을 실행하는 환경.</li>
                    <li>튜링 완전성: 스마트 계약이 튜링 완전한 언어로 작성됨. > 계약이 매우 유연하고 강력한 기능을 제공할 수 있음.</li>
                </ul>

                <h4>비트코인과 이더리움은 설계 목적이 어떻게 다른가?</h4>
                비트코인: 디지털 통화(가치 저장 및 거래)가 목적. 단순하고 안정적인 네트워크 설계<br>
                이더리움: 스마트 계약 및 DApp 실행이 목적. 유연하고 확장 가능한 네트워크 설계.

                <h4>ECDSA가 뭔가요?</h4>
                <li>타원 곡선 암호학을 기반으로한 디지털 서명 알고리즘.</li>
                <li>기존 RSA보타 짧은 키 길이로도 높은 보안성을 제곰하며, 개인키로 서명을 생성하고 공개키로 이를 검증하는 방식으로 동작함.</li>
                <li>장점: 속도와 보안성을 동시에 확보할 수 있음.</li>
                <li>비트코인, 이더리움에서 거래 서명과 인증에 쓰임.</li>

                <h4>이더리움의 블록체인 모델은 비트코인과 어떻게 다른가요?</h4>
                비트코인은 UTXO 기반 모델, 이더리움은 계정 기반 모델<br>
                비트코인 모델에서는 UTXO 합이 잔액임, 이더리움에서는 계정 잔액.

                <h4 style="text-decoration: underline; color:#ff4d94;">이더리움 계정의 종류 2가지는 무엇인가요?</h4>
                <ul>
                    <li>외부 소유 계정(EOA): 사람이 씀. 프라이빗 키가 있어 디지털 서명 할 수 있고 트랜젝션 생성 할 수 있음.</li>
                    <li>스마트 계약 계정(CA): 특정 코드가 배포된 계정. 프라이빗 키가 없어서 트잭 생성 못함 (출금 못함). 스스로 트잭 생성은 못하지만 EOA가 요청한 트랜젝션 만들 수는 있음 (인터널 트랜잭션).</li>
                </ul>

                <h4 style="text-decoration: underline; color:#ff4d94;">이더리움의 논스와 비트코인의 논스는 어떻게 다른가요?</h4>
                <ul>
                    <li>해당 계정에서 보낸 트랜잭션의 횟수/순서 (비트코인에서는 시도 횟수로 PoW 채굴 과정에서 유효한 해시를 찾기 위해 사용)</li>
                    <li>이중지불을 비트코인에서는 UTXO로 방지 - 사용된 UTXO 값은 더하지 않음. 미사용된거 합치면 잔액. 이미 소모된 UTXO를 다시 사용하는 트잭은 유효하지 않고 네트워크에서 거부됨.</li>
                    <li>이중지불을 이더에서는 논스로 막음. 즉 재생 공격(replay attack)을 방지함.</li>
                    <li>이더리움의 논스는 계정별 트랜잭션의 고유 식별자 역할을 함.</li>
                </ul>

                <h4>이더리움에서 재생 공격 방지 방법은?</h4>
                <ul>
                    <li>논스 사용</li>
                    <li>체인 ID: 포크된 체인에서 체인 ID를 도입해 각 체인을 구분함. 예: 이더리움과 이더리움 클래식은 서로 다른 체인 ID 사용</li>
                </ul>

                <h4>EVM이란?</h4>
                <ul>
                    <li>Ethereum Virtual Machine. 우리가 작성한 코드와 이더리움 블록체인 사이에 존재하는 가상 머신.</li>
                    <li>여행갈 때 가져가는 어댑터</li>
                    <li>이더리움에서 스마트 계약 기반의 dApp은 Solidity로 작성됨. Solidity 코드를 Solidity 컴파일러(solc)를 사용해 EVM이 이해할 수 있는 Bytecode로 변환.  -> 바이트코드를 이더리움 네트워크로 배포. -> EVM이 바이트코드를 해석하고 실행함.</li>
                </ul>

                <h4>EVM에서 바이트코드는 스택 기반 아키텍처로 실행됩니다. 바이트코드가 실행되는 과정을 설명해보세요.</h4>
                EVM은 명령어를 Opcode로 해석하며 모든 연산은 스택을 이용해 처리됨.<br>
                스택, 즉 프링글즈 과자처럼 먼저 들어온 대로 쌓아 올리고, 맨 마지막에 올린 것 부터 꺼냄.

                <h4>EVM에는 보안을 위한 어떤 장치가 있나요?</h4>
                <li>보안 격리(Sandboxing): 스마트 계약 간 충돌을 방지하며, 잘못된 코드가 네트워크나 다른 계약에 영향을 미치지 않도록 격리된 실행 환경을 제공함.</li>
                <li>가스(Gas): 바이코드 실행에는 가스 비용이 소모됨. 각 Opcode는 실행 비용에 따라 특정 가스 양이 할당됨.</li>

                <h4>스마트 컨트랜트란?</h4>
                <ul>
                    <li>블록체인 네트워크에서 호스팅되고 실행되는 프로그램으로, 특정 조건을 설정하고 해당 조건이 충족되면 자동으로 계약을 이행하도록 설계된 자동화된 계약 실행 프로토콜임.</li>
                        <ul><li>프로토콜: 컴퓨터나 네트워크 시스템이 데이터를 주고받을 때 따르는 규칙과 절차. 데이터 전송 방식, 오류 처리, 인증 절차 등을 표준화하여 다른 시스템간 원활한 통신을 가능하게 함. 디지털 세계에서 ‘언어’와도 같은 역할을 함.</li></ul>
                    <li>블록체인의 분산 구조와 암호화 기술로 인해 계약 조건이나 이행 내용을 변조하기 어렵고, 계약을 신뢰하기 위한 제3자가 필요하지 않음.</li>
                    <li>닉 재보의 정의: 계약 조건을 실행하는 전산화된 트랜잭션 프로토콜은 일반적인 계약 조건을 만족하고, 악의적이거나 우발적인 예외를 최소화하며, 신뢰할 만한 중개자의 필요성을 최소화 하는 것을 목표로 한다. 마치 자판기와 같다.</li>
                </ul>

                <h4>스마트 컨트랙트가의 장점이 뭔가요? 일반적인 중앙집권화된 디지털 계약과 비교해 설명하세요.</h4>
                <ul>
                    <li>보안: 분산형 블록체인에서 실행되어 Single point of failure 위험이 없음.</li>
                    <li>신뢰성: 모드 노드에 의해 검증되어 계약 위변조가 매우 어려움.</li>
                    <li>공평함: 수수료 없고, 특정 용의적 목적의 제3자가 필요 없음.</li>
                    <li>효율성</li>
                </ul>

                <h4>스마트 컨트랙트의 한계점은?</h4>
                <ul>
                    <li>배포 후 작동 수정이 불가능함: 보안 허점이 발견될 경우 해킹에 취약해 질 수 있음. 프록시 패턴과 같은 컨트랙트 업그레이드 방법이 개발되었으나 완벽한 해결책은 아님.</li>
                    <li>블록체인 외 정보를 스스로 얻지 못함. 오라클을 사용하지만, 그 데이터가 신뢰할 수 있는지, 전달 과정에서 오류가 발생하지 않는지 확인해야 함. 악의적인 데이터 입력 시 계약이 의도하지 않은 방식으로 실행될 위험도 있음.</li>
                </ul>

                <h4>지갑에 EVM 계열 블록체인 노드를 어떻게 연결하나요?</h4>
                지갑은 특정 노드의 RPC URL(노드 주소)을 이용해 블록체인에 저장된 온체인 데이터를 요청할 수 있음. 이러한 노드와의 통신 방식은 RPC(Remote Procedure Call)이라고 하며 RPC URL을 통해 연결함.

                <h4>메타마스크에서 다른 지갑 주소로 KAIA 보내며 컨펌을 누르면 어떤 일이 벌어지나요?</h4>
                <ol>
                    <li>트랜젝션 세부 정보가 명확히 표시됨. 유저는 승인 진행</li>
                    <li>개인키로 트랜잭션에 디지털 서명</li>
                    <li>서명된 트랜잭션은 네트워크로 브로드캐스트 되어 처리됨</li>
                    <li>네트워크가 트랜잭션 처리하고 블록에 포함한 뒤 상태 업그레이드</li>
                </ol>
                </p>
            </article>


            <article>
                <h3>기초 - 웹 개발 이해하기</h3>
                <p> 2025년 2월 10일</p>
                <h4>웹이란?</h4>인터넷 위에서 동작하는 정보 시스템

                <h4>인터넷과 웹은 어떻게 다른가?</h4>
                인터넷은 도로, 웹은 도로를 달리는 자동차. <br>
                인터넷은 물리적 네트워크 인프라, 웹은 웹 브라우저를 통해 사람들이 정보를 검색, 읽기, 쓰기 할 수 있고 상호작용할 수 있는 공간
            
                <h4>웹은 왜 만들어 졌나요? (어떤 문제를 해결하기위해 만들어졌나요?)</h4>
                각 과학 연구소마다 다른 시스템으로 데이터 저장 및 접근 > 데이터 찾고 이해하기 위해 시간과 노력 많이 소요. > 하나의 통합된 플랫폼을 통해 데이터 공유하고 접근 가능성 높일 필요성

                <h4>군사나 학술 목적으로 사용되던 인터넷이 언제부터 확산화되기 시작했나요?</h4>
                <ul>
                    <li>1983년 TCP/IP 프로토콜이 만들어 지면서.</li>
                    <li>TCP/IP 프로토콜: 우리만의 규약.</li>
                    <li>데이터를 패킷화, 주소 지정 및 전송, 라우팅, 수신하는 방법에 대한 일련의 규칙 제공 (마치 택배 배달 하는 것처럼)</li>
                </ul>

                <h4>팀 버너스가 제안한 www의 개념을 설명하세요.</h4>
                <ol>
                <li>하이퍼텍스트(링크)의 활용</li>
                <li>인터넷을 활용한 글로벌 정보 공유</li>
                <li>웹의 구성 요소 - HTML: 웹 문서 구조 정의; 태그 기반 언어이고 태그 안에는 약속된 기능이 있음</li>
                    <ul><li>HTTP: 클라이언트와 서버 간에 데이터를 주고받는 프로토콜; 요청과 응답 구조</li>
                    <li>URL: 웹 리소스의 위치를 정하는 주소</li>
                    <li>URL 구조: 프로토콜://도메인/경로?쿼리문자열# 프래그먼트</li>
                        <ul><li>프로토콜: 데이터를 주고받는 방식</li>
                        <li>도메인: 서버 주소 또는 IP 주소</li>
                        <li>경로: 서버 내에서 자원의 위치</li>
                        <li>프래그먼트: 문서 내 특정 위치</li></ul>
                    </ul>
                </ol>
            
            <h4>현재 웹 표준을 담당하는 기관은 어디인가요?</h4>팀 버너스 리가 주도하는 W3C(World Wide Web Consortium)

            <h4>Web의 발전 과정을 설명하세요. </h4>
            <ol>
                <li> Web 1.0 - 사용자가 데이터를 받는다. 예: 게임 공지</li>
                <li>Web 2.0 - 사용자도 데이터 만들고 공유할 수 있다. 예: 홈페이지</li>
                <li>Web 3.0 - 지능화, 개인화, 탈중앙화를 중심으로 하는 차세대 웹.</li>
                    <ul><li>사용자의 데이터 소유권과 분산 네트워크 강조</li>
                    <li>블록체인, AI, 스마트 계약, 시맨틱 웹</li>
                    <li>확장성 문제: 네트워크가 커질수록 처리 속도가 느려지는 문제</li>
                    <li>네트워크 속도 문제: 블록체인은 전 세계 노드 간 데이터 전파가 필요하며, 인터넷 속도가 느려면 합의 과정이 지연됨</li></ul>
            </ol>

            <h4>DNS란?</h4>
            Domain Name System. 도메인 이름과 IP 주소를 연결해 주는 시스템.

            <h4>클라이언트 동작 과정을 설명하세요.</h4>
            <ol>
                <li>사용자가 브라우저 주소창에 https://www.example.com 입력</li>
                <li>브라우저가 해당 URL의 DNS를 조회하고 서버 IP 주소 획득</li>
                <li>서버에 HTTP GET 요청을 전송</li>
                <li>서버로부터 HTML 문서와 관련 리소스를 응답받음</li>
                <li>브라우저가 HTML, CSS, JavaScript를 해석하여 사용자 화면에 표시</li>
                <li>사용작 버튼을 클릭하거나 입력을 추가하면 추가 요청을 서버로 전송송</li>
            </ol>

            <h4>서버 종류는 어떤 것이 있나요?</h4>
            <ul>
                <li>웹 서버 : 주로 배포 단계에서</li>
                <li>애플리케이션 서버: 동적 요청 처리; 예: 데이터베이스와 상호작용, API 호출, 주로 서비스 로직 개발에 사용</li>
                <li>데이터베이스 서버</li>
                <li>파일 서버 : 클라이언트에 파일을 저장하고 전송. 클라우드 기반 파일 서버가 주로 사용됨.</li>
            </ul>

            <h4>풀스택 개발자</h4>클라이언트와 서버의 구성 요소를 모두 개발할 수 있는 개발자

            <h4>클라이언트와 서버는 어떻게 다른가요?</h4>
            행사장 뒷편에서 물품을 나르는 역할을 하는건 서버.<br>행사장에서 참가자들 관리하는건 클라이언트

            <h4>블록체인의 노드와 웹 개발의 노드는 어떻게 다른가요?</h4>
            블록체인에서의 노드는 블록체인 네트워크에 연결된 컴퓨터를 말하며 여기서 노드는 데이터 저장, 검증 등을 한다.<br>
            웹 개발(Node.js)에서의 노드는 자바스크립트를 이용해 시스템을 만드는 서버이다.

            <h4>html에 대해 말해보세요.</h4>
            <ul>
                <li>브라우저가 HTML 문서를 해석하고 렌더링 하는 기능을 가지고 있음.</li>
                <li>Head - 속성; Body - 구조</li>
                <li>Html 문서는 브라우저가 올바르게 해석할 수 있도록 .html 파일 확장자가 필요함.</li>
            </ul>

            <h4>CSS에 대해 말해보세요.</h4>
                <ul>
                    <li>Style 태그 안에 넣어야 함</li>
                    <li>선택자(selector)를 사용해 특정 HTML 요소에 스타일을 적용.</li>
                    <li>P { color: red; }</li>
                    <li>선택자Selector { 속성property: 속성값property value;}</li>
                    <li>박스모델: padding - border - margin</li>
                </ul>

            <h4>JavaScript에 대해 말해보세요.</h4>
            <ul>
                <li>Script 태그 안에 넣어야 함</li>
                <li>다양한 라이브러리(jQuery, Lodash) 및 프레임워크(React, Vue.js)와 함께 사용 가능</li>
            </ul>

            <h4>터미널 기반 텍스트 편집기를 사용해 내용 입력 후 저장하는 과정은?</h4>
            <li>% vim test.html</li>
            <li>I -> 내용 입력 -> ESC -> :wq (저장 후 종료)</li>

            <h4>코딩이란?</h4>명령어를 사용해 컴퓨터에 작업을 지시하는 과정. 이를 위해 코드 실행 가능한 런타임 환경에서 구동해야 함.

            <h4>VSCode에서 코드 자동 정렬 방법</h4>
            macOS: Shift + Option + F<br>
            혹은 마우스 우클릭 > “Format Document” 누르기

            주의 사항: VS Code 확장프로그램 Codeium: AI Coding Autocomplete!은 지금은 쓰지 말 것.
            
            </article>

            <article>
                <h3>Git</h3>
                <p>2025년 2월 11일</p>
                <h4>깃 워크플로우</h4>
                깃은 파일 상태 관리를 위해 다음 세 가지 영역을 사용: 
                <ol>
                    <li>Working Directory: 로컬에서 작업중인 파일들이 위치하는 공간. 파일이 수정되면 Git이 추적하지만 아직 저장소에 반영되지 않은 상태</li>
                    <li>Staging Area: 커밋하기 위해 준비된 파일들이 임시로 저장된 공간. git add 명령으로 스테이징 영역에 추가</li>
                    <li>Repository: Git 이 관리하는 데이터베이스. git commit 명령으로 스테이징 영역의 파일이 저장소에 반영되고 변경 이력이 기록됨.</li>
                </ol>
                파일을 로컬에서 원결으로 깃허브에 올릴 때 쓰는 명령어는?
                <ol>
                    <li>git add (파일이름) 혹은 git add . : 마치 노드 멤풀에 트랜잭션이 모여있는 것과 같은 상태</li>
                        <ul>파일 상태는 Untracked(Git에서 관리하지 않는 파일) 또는 Modified(수정된 파일)로 표시됨</ul>
                        <ul>스테이징 영역에 추가</ul>
                    <li>git commit -m '메세지': 동료들이 내 메세지를 보고 어떤 작업을 했는지 파악할 수 있도록 메세지 작명</li>
                        <ul>변경사항을 로컬 저장소에 기록</ul>
                    <li>git push origin main: 여기서 origin은 이 코드가 원래 있어야 할 곳 (마스터 브랜치, 여기선 원격저장소); main은 브랜치</li>
                        <ul>원격 저장소에 업로드</ul>
                </ol>

                <h4>브랜치</h4>
                핵심 개념 
                <ul>
                    <li>독립적인 작업 공간: 기존 코드에 영향을 주지 않고 새 작업 수행 가능</li>
                    <li>경량화된 포인터: Git에서 브랜치는 특정 커밋을 가리키는 포인터(참조); 새로운 커밋이 추가되면 브랜치는 자동으로 해당 커밋을 가리키도록 이동함</li>
                    <li>기본 브랜치와 병렬 브랜치: main과 master; feature와 fix</li>
                </ul>

                <p>브랜치끼리 충돌할 때 덮어쓰지 말기</p>
                다음 명령어 쓰기:<br> 
                git pull origin main --no-rebase 
                <ul>
                    <li>rebase: 우리 코드가 먼저다, 덮어 써라는 뜻</li>
                    <li>덮어쓰지 않도록 no rebase</li>
                </ul>
                <p>
                    브랜치 만들고 그 브랜치로 이동할 때 쓰는 명령어:<br>
                    git checkout -b 브랜치 이름 
                </p>
                충돌 방지 위해 아래 습관화 하기 (출근 하자 마자 할 것): 
                <ul>
                    <li>git fetch --all: 모든 원격 저장소 최신호</li>
                    <li>git pull origin main: 원격 저장소 origin의 main 브랜ㅇ치 코드 가져옴</li>
                </ul>
            </article>

            <article>
                <h3>HTML</h3>
                <p>2025년 2월 12일</p>
                
                <h4>HTML이란?</h4>
                <p>웹 페이지의 뼈대를 구성하는 마크업 언어.</p>
                
                <h4>HTML의 특징은?</h4>
                    <ul>
                        <li>하이퍼텍스트: 문서간 연결</li>
                        <li>마크업 언어: 텍스트에 태그를 추가해 구조와 의미 정의</li>
                        <li>브라우저가 읽고 해석해 웹페이지로 렌더링</li>
                    </ul>
                    
                <h4>HTML의 구성요소는?</h4> 
                    <ol>
                        <li>!DOCTYPE html: 브라우저가 HTML5 규격에 맞게 콘텐츠 해석하도록 지정</li>
                        <li>html: HTML 문서의 루트요소로 모든 HTML 태그를 감쌈</li>
                        <li>head: 문서의 메타 정보 담음</li>
                        <li>body</li>
                    </ol>

                <h4>속성(attribute)</h4>
                <p>태그에 추가 정보를 제공해 해당 요소의 동작이나 스타일을 설정하는 데 사용됨. <br>
                    속성명="값"의 형식으로 표현됨 </p>
                    자주 사용하는 속성명
                    <ul>
                        <li>id, class</li>
                        <li>href</li>
                        <li>src</li>
                        <li>alt</li>
                        <li>style</li>
                        <li>title</li>
                        <li>input</li>
                    </ul>
                <a href="https://developer.mozilla.org/ko/docs/Web/HTML/Element">HTML 요소 참고서</a>
            </article>

            <article>
                <h4>SEO, 검색 엔진 최적화</h4>
                <p>검색 엔진에서 웹사이트가 더 높은 순위에 노출되도록 최적화하는 작업</p>
                <p>SEO 태그 사용의 중요성</p>
                <ul>
                    <li>검색 엔진에 정보 제공</li>
                    <li>검색 순위 향상</li>
                    <li>사용자 경험 개선</li>
                </ul>
            </article>
        
            <article>
                <h3>HTTL과 CSS는 어떻게 연결하나요?</h3>
                <p>Link 태그 또는 내부 스타일로 연결할 수 있습니다.</p>
                <ol>
                    <li>외부 스타일시트 연결: link rel="stylesheet” href=“css/styles.css”</li>
                    <li>내부 스타일시트: HTML 파일 안에서 style 태그를 사용</li>
                    <li>인라인 스타일: HTML 요소에 직접 스타일 정의</li>
                </ol>
                
                외부 스타일시트 연결할 때 주의 사항은? 
                <ul>
                    <li>경로 설정</li>
                    <li>파일 확장자는 .css</li>
                    <li>스타일시트의 로딩 순서는 순서대로 로드됨<li>
                </ul>
                
                <h4>CSS에서 ID와 Class는 각각 어떻게 쓰일까?</h4>
                <p>ID는 문서 내에서 유일해야 함. 한 요소에만 적용 가능</p>
              
                <h4>링크 스타일링 할 때 어떤 태그를 쓰나요?</h4>
                <p>a</p>
                
                <h4>Flexbox와 Grid에서 누구에게 속성을 주나요?</h4>
                <p>부모에게 속성을 주고, 부모가 자식들을 정렬한다.</p> 
                
               <h4>미디어 쿼리란?</h4>
                <p>디바이스의 화면 크기, 해상도, 방향에 따라 다른 스타일을 적용할 수 있도록 도와줌. 이를 사용하면 반응형 웹 디자인(Responsive Web Design)을 구현할 수 있음.</p>
            </article>

            <article>
                <h3>Javascript (1) </h3>
                <p>2025년 2월 14일</p>
                <h4>자바스크립트에서 주석 다는 방법</h4>
                <p>// 다음에 작성, 혹은 /*, */ 사이에 작성</p>

                <h4>자바스크립트의 타입이란?</h4>
                <p>컴퓨터가 데이터를 어떻게 이해하고 처리할지를 나타내는 것. 같은 타입끼리 써야 함.</p>

                <h4>타입을 확인하는 방법은?</h4>
                <p>typeof라는 키워드 사용. 
                    <br>console.log(typeof 42); // "number"
                    <br>console.log(typeof null); // "object"
                </p>

                <h4>Math 내장 객체의 대표적은 메서드는?</h4>
                <ul>
                    <li>Math.floor(): 괄호 안의 숫자를 내림하여 반환.</li>
                    <li>Math.ceil(): 괄호 안의 숫자를 올림하여 반환</li>
                    <li>Math.round(): 괄호 안의 숫자를 반올림 하여 반환.</li>
                </ul>
                    문자열 주요 메서드: 지갑 주소 확인.비교할 때 유용함<br>
                    논리 부정 연산자(!) 주로 언제 쓰이는지: 값이 없으면 오류를 내보내줘 할 때. 오류가 날 경우 다른 방식으로 할 수 있도록.<br> 
                    변수 : 재사용 가능<br> 
                    변수 선언 > 메모리에 공간 확보<br> 
                    할당 > 값을 메모리 공감에 저장<br>
                    =는 저정한다는 뜻<br> 
                    템플릿 리터럴: 문자의 내부에 변수를 삽입할 수 있는 기능. 정말 많이 쓰임.<br>
                    Return문: 터미널 출력이 안됨. </p>
            </article>

            <article>
                <h3></h3>
                <p></p>
                <h4></h4>
            </article>

            <article>
                <h3>Javascript (2)</h3>
                <p>2025년 2월 17일</p>
                <h4>조건문 if</h4>
                <p>동치연산자(===): 두 피연산자가 동일하면 true, 아니면 false를 반환함.<br>
                !== 는 반대로 두 피연산자가 동일하지 않으면 true, 동일하면 false를 반환함.<br>
                예: let name = 'bobLee'; <br>
                    if (name !== 'eliceKim') {console.log('가입할 수 있는 이름입니다.');}</p>
                <p>비교연산자(>, <, >-, <=)</p>
                <p>논리연산자(&&, ||): ||은 여러 조건 중 하나만 true 여도 true로 판단함. && 은 여러 조건 중 하나라도 false면 false로 판단.</p>  
                <p>부정연산자(!): 조건이 true이면 false, 조건이 false이면 true를 리턴함.</p>
            
                <h3>삼항 조건 연산자</h3>
                <p>if문과 else 문을 삼항 조건 연산자로 바꿔쓸 수 있음.<br>
                예: let nim = 5; <br>
                 num % 2 === 0 ? console.log('짝수') : console.log('홀수'); </p>
                
                <h3>반복문 for문</h3>
                <p>for (초기값; 조건식; 증감식) { // 실행코드 }</p>
                <p>예: 숫자 1부터 5까지의 수를 모두 더해라.<br>
                    let result = 0; <br>
                    for (let num = 1; num <=5; num++) { <br>
                    result = result + num; <br> } <br><br>
                    console.log(result); //15

                </p>

                <h3>문자열과 반복문</h3>
                <p>예1: let str = 'rocketboost'; <br>
                console.log(str[0]); // 'r' <br>
                console.log(str[4]; // 'e' <br><br>
            
                예2: let str = 'rocketboost';<br>
            console.log(str.indexOf('c')); //2 <br>
            console.log(str.indexOf('e')); //4</p>
        
            <h3>반복문의 중첩</h3>
            <p>반복문 내부에 또 다른 반복문을 사용할 수 있음. 단, 컴퓨터가 느려질 수 있음.</p>
            <p>예: 이중반복문으로 구구단 전체를 출력하는 코드를 구현하세요. <br>
            for (let i = 2; i <= 9; i++) {<br>
            console.log(`${1}단`);<br>
            for (let j = 1; j <= 9; j++) { <br> 
            console.log(`${i} x ${j} = ${i * j}`); <br> } <br> }</p>
                
            <h3>while문</h3>
            <p>언제까지 반복할 지 모를 때 사용. 예를 들어 내 폴더 안에 몇 개의 파일이 있는지 모를 때.<br>
            while문 작성할 때 조건식이 false로 평가되는 순간이 있는지 반드시 주의 (무한 루프 주의). <br>
        do...while문: while 뒤에 오는 조건식이 true로 평가되는 동안 do 뒤에 오는 코드블록 내부의 코드를 반복해서 실행.</p>
        
        </article>

        </section>

        <section id="contact">
            <h2>문의</h2>
            <p>
                이메일: <a href="mailto:chatjip9@gmail.com">chatjip9@gmail.com</a>
            </p>
            
            <p style="color: #46922f; font-style: italic;">블록체인에 대해 함께 공부하거나 이야기하고 싶으신 분은 이메일 주소를 남겨주세요.
                <form>
                    <input type="email" placeholder="이메일을 입력하세요" required>
                    <button type="submit" onclick="showMessage()"
                    style="background-color: #ff4d94; border: none; color: darkblue;"
                    >제출</button>
                </form>
            </p>    
            
            <script>
                function showMessage() {
                    alert("감사합니다");
                }
            </script>
        </section>
    </main>

    

    <footer>
        <p>&copy; 2025 나의 블록체인 일지. All rights reserved.</p>
    </footer>

</body>
</html>